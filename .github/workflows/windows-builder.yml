# GitHub Actions Workflow for Building Windows Executable
#
# Why this workflow exists:
# 1. Automates the build of a Windows .exe for the Python application.
# 2. Enables building from a macOS (or any other OS) developer environment using GitHub-hosted Windows runners.
# 3. Stores the built executable as a downloadable artifact.
# 4. Provides a scalable CI/CD foundation for future enhancements like code signing and release packaging.

name: Build Windows Executable (windows-builder.yml)

# Controls when the workflow will run
on:
  # Triggers the workflow on push events but only for the new-licenses-windows-builder branch
  push:
    branches: [ new-licenses-windows-builder ]
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  build-windows:
    name: Build Python App for Windows
    runs-on: windows-latest # Use a GitHub-hosted Windows runner
    env:
      CHROME_ZIP_URL: "https://storage.googleapis.com/chrome-for-testing-public/137.0.7151.68/win64/chrome-win64.zip"

    defaults:
      run:
        shell: bash # Prefer bash for consistency, though some steps might use powershell

    steps:
      # Step 1: Check out the repository code
      - name: Check out repository
        uses: actions/checkout@v4

      # Step 1.5: Clean workspace before build
      - name: Clean workspace
        run: |
          git clean -xdf
        # -x: Remove ignored files too
        # -d: Remove directories
        # -f: Force (required if clean.requireForce is not false)

      # Step 2: Set up Python environment
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip' # Cache pip dependencies

      # Step 2.5: Build React frontend
      - name: Build React frontend
        run: |
          echo "Building React frontend..."
          cd front-end-react
          npm ci
          npm run build
          echo "React frontend build complete. 'dist' folder should now exist in front-end-react."
        # This ensures front-end-react/dist is available for PyInstaller

      # Step 2.6: Create .env file from secrets
      - name: Create .env file
        working-directory: backend-web-scrapper # Create .env in the backend directory
        env:
          KEYGEN_PRODUCT_TOKEN: ${{ secrets.KEYGEN_PRODUCT_TOKEN }}
          KEYGEN_ACCOUNT_ID: ${{ secrets.KEYGEN_ACCOUNT_ID }}
        run: |
          echo "Creating .env file in $(pwd)..."
          echo "KEYGEN_PRODUCT_TOKEN=${KEYGEN_PRODUCT_TOKEN}" > .env
          echo "KEYGEN_ACCOUNT_ID=${KEYGEN_ACCOUNT_ID}" >> .env
          echo ".env file created successfully."
          echo "Contents of .env:"
          cat .env
        shell: bash

      # Step 3: Build Windows Executable using .spec file
      - name: Build Windows Executable
        working-directory: backend-web-scrapper # Set working directory for the entire step
        shell: cmd # Using cmd for reliable venv activation and PyInstaller on Windows
        run: |
          echo "Current directory: %CD%"
          echo "Setting up virtual environment (in %CD%) and installing dependencies..."
          python -m venv venv
          call venv\Scripts\activate
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller
          echo "Dependencies installed."
          
          echo "--- Listing files in current directory (%CD%) before build ---"
          dir
          echo " "
          echo "--- Verifying .env presence and content ---"
          type .env || echo ".env not found or type command failed"
          echo " "
          echo "--- Verifying main.spec presence and content ---"
          type main.spec || echo "main.spec not found or type command failed"
          echo " "

          echo "--- Cleaning up old build artifacts (build/ and dist/) ---"
          if exist build (
            echo "Removing old build directory..."
            rd /s /q build
          ) else (
            echo "No old build directory to remove."
          )
          if exist dist (
            echo "Removing old dist directory..."
            rd /s /q dist
          ) else (
            echo "No old dist directory to remove."
          )
          echo "Cleanup finished."
          echo " "
          
          echo "--- Starting PyInstaller build using main.spec ---"
          pyinstaller --noconfirm main.spec
          echo "--- PyInstaller build finished ---"
        # The output (dist folder) will be in backend-web-scrapper/dist/
        # All build configurations are now in main.spec.

      # Step 4: Cache and Set Up ChromeDriver (Remains largely the same, just re-numbered logic)
      - name: Cache ChromeDriver
        id: cache-chromedriver
        uses: actions/cache@v4
        with:
          path: chrome-win64.zip
          key: ${{ runner.os }}-chromedriver-${{ env.CHROME_ZIP_URL }}
          restore-keys: |
            ${{ runner.os }}-chromedriver-
      - name: Download and Set up ChromeDriver
        shell: pwsh
        env:
          CACHE_HIT: ${{ steps.cache-chromedriver.outputs.cache-hit }}
        run: |
          echo "Start ChromeDriver Setup: $(Get-Date -Format s)"
          if ($env:CACHE_HIT -ne 'true') {
            echo "Cache miss for ChromeDriver. Downloading..."
            Invoke-WebRequest -Uri "${{ env.CHROME_ZIP_URL }}" -OutFile chrome-win64.zip
          } else {
            echo "ChromeDriver cache hit. Skipping download."
          }
          Expand-Archive -Path chrome-win64.zip -DestinationPath ./
          $ChromedriverPath = Join-Path -Path $env:GITHUB_WORKSPACE -ChildPath "chrome-win64/chrome-win64"
          echo "Adding to PATH: $ChromedriverPath"
          echo "$ChromedriverPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          chromedriver --version
          echo "End ChromeDriver Setup: $(Get-Date -Format s)"
      # Step 6: Upload the built executable as an artifact
      # This makes the dist/ folder available for download from the GitHub Actions run page.
      - name: Upload Windows Executable Artifact
        uses: actions/upload-artifact@v4
        with:
          name: web_scraper_windows_exe # Name of the artifact
          path: backend-web-scrapper/dist/ # Path to the folder to upload
          if-no-files-found: error # Fail the step if dist/ is empty or not found.
